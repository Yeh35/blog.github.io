<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Document on sango.h</title>
    <link>https://yeh35.github.io/blog.github.io/documents/</link>
    <description>Recent content in Document on sango.h</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 08 Jun 2020 22:00:00 +0900</lastBuildDate>
    
	<atom:link href="https://yeh35.github.io/blog.github.io/documents/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Spring JPA 1편: Build UP!!</title>
      <link>https://yeh35.github.io/blog.github.io/documents/spring/spring-jpa-core/</link>
      <pubDate>Mon, 08 Jun 2020 22:00:00 +0900</pubDate>
      
      <guid>https://yeh35.github.io/blog.github.io/documents/spring/spring-jpa-core/</guid>
      <description>관계형 DB 와 Java 관계형 DB 와 Java를 연결하는 기본은 JDBC이다. JDBC를 기반으로 여러 방식들이 제시되었다.
JDBC JDBC는 Java Data Base Connectivity으로 JDK 1.1을 기준으로 Java의 표준(java.sql.*)이 되었다.
Java 표준으로 정해졌기 떄문에 사용하려는 DBMS 진영에서 JDBC 드라이버(API를 구현한 라이브러리)를 제공하면 어떤 DBMS든 쉽게 사용할 수 있을 줄 알았다. 하지만 DBMS와 연결하는 API만 표준으로 제공할뿐 실질적은 Query는 직접 작성해야겠다.
 예제  Mybatis: SQL Mapping JDBC를 그냥 사용하니 코드와 SQL이 같이 있어서 불편해.</description>
    </item>
    
    <item>
      <title>Java에서 Assert 제대로 쓰기</title>
      <link>https://yeh35.github.io/blog.github.io/documents/java/java-assert/</link>
      <pubDate>Sun, 07 Jun 2020 21:24:00 +0900</pubDate>
      
      <guid>https://yeh35.github.io/blog.github.io/documents/java/java-assert/</guid>
      <description>Assert Assert는 개발/테스트 단계에서 파라미터가 제대로 넘어왔는지 계산이 제대로 됬는지 혹은 특정 메소드가 작동하는 한계상황(Null이 들어오면 작동안함)을 정하는 용도로 사용한다.
Java에서 Assert Java에서는 JDK 1.4부터 assert라는 예약어 를 지원했다.
assert [Boolean] // 참이면 Pass, 거짓이면 AssertionError실행옵션 세팅 java default 실행에서는 assert가 모두 제외된다. 실행시 -ea 옵션을 줘야지만 작동하니 개발/테스트 일때는 설정해놓기
java -eaIntellij에서는 기본 JVM 옵션이 -ea이다. (그래도 혹시 모르니 확인하기..) (assert-intllij-setting)[/blog.github.io/img/documents/java/assert-intllij-setting.png]
Assert를 어떻게 써야할까? Assert는 아무데나 덕지덕지 붙여도 상관이 없지만, 꼭 넣으면 좋은 곳들이 있다.</description>
    </item>
    
    <item>
      <title>Spring Boot Directory</title>
      <link>https://yeh35.github.io/blog.github.io/documents/spring/spring-boot-directory/</link>
      <pubDate>Fri, 05 Jun 2020 20:15:22 +0900</pubDate>
      
      <guid>https://yeh35.github.io/blog.github.io/documents/spring/spring-boot-directory/</guid>
      <description>들어가기전 Yun Blog님 블로그를 참고하였습니다 저의 멋대로 정리한 것임으로.. 자세한 내용은 Yun Blog님 블로그를 보시길 권장드립니다.
패키지 구성의 2가지 유형   계층형 : 각 계층을 대표하는 디렉터리를 기준으로 코드를 작성
└── src├── main│ ├── java│ │ └── com│ │ └── example│ │ └── demo│ │ ├── DemoApplication.java│ │ ├── config│ │ ├── controller│ │ ├── dao│ │ ├── domain│ │ ├── exception│ │ └── service│ └── resources│ └── application.</description>
    </item>
    
    <item>
      <title>람다식</title>
      <link>https://yeh35.github.io/blog.github.io/documents/java/lamdba-java/</link>
      <pubDate>Wed, 03 Jun 2020 20:15:00 +0900</pubDate>
      
      <guid>https://yeh35.github.io/blog.github.io/documents/java/lamdba-java/</guid>
      <description>들어가기전 IDE에서 추천해주니 의심하지 않고 사용을 하였지만 어떤식으로 작동하는 것인지
알아보면서 정리한 내용이다.
람다식(Lamdaba Expressions)? 처음 람다라는 이야기를 들었을 떄 &amp;lsquo;람보&#39;가 생각나는&amp;hellip;. 나만 그런건가?&amp;hellip;
람다식은 Java8부터 도입되었다.
람다식은 익명함수(anonymous function)을 생성하기 위한 식으로 함수 지향 프로그래밍에 사실 더 가깝다.
매개변수를 가진 코드블록에 불가하지만, 런티임 시 익명 구현 객체를 생성한다.
람다식를 사용하기 위해서는 규칙이 있다.
람다식이 구현할 인터페이스에 추상메소드가 한개만 존재햐아한다.
Java8이전에 코드에 익숙하다면 간결해 보이지만 조금 낫선감은 없지 않다.
정리하면 람다식은 로컬 익명 구현객체를 생성을 하며 주로 Interface의 메소드를 간편하게 구현하는 목적으로 사용한다</description>
    </item>
    
    <item>
      <title>Junit5 한번에 끝내기</title>
      <link>https://yeh35.github.io/blog.github.io/documents/java/junit5/</link>
      <pubDate>Tue, 02 Jun 2020 21:24:00 +0900</pubDate>
      
      <guid>https://yeh35.github.io/blog.github.io/documents/java/junit5/</guid>
      <description>소개 junit은 단위 테스트를 작성하는 자바 개발자 93%가 사용하는 테스팅 프레임워크 이다. 테스트 코드를 작성해야하는
구성  JUnit Platform : 테스트를 실행시켜주는 런처를 제공, TestEngine API가 제공된다. Jupiter: JUnit 5를 지원하는 TestEngine API의 구연체 Vintage: JUnit 4, 3를 지원하는 TestEngine API의 구연체  의존성 추가  2.2+ 버전의 스프링 부트 프로젝트라면 spring-boot-starter-test에 기본으로 탑제가 되어있다. 아니라면&amp;hellip; &amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;org.junit.jupiter&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;junit-jupiter-engine&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;5.5.2&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;  기본 에노테이션은  @Test @BeforeAll / @AfterAll : 전체 @Test 메소드 전후 @BeforeEach / @AfterEach : 각 @Test 메소드 전후 @Disabled : @Test 메소드 실행 안하기  예제 import org.</description>
    </item>
    
    <item>
      <title>Docker Hub</title>
      <link>https://yeh35.github.io/blog.github.io/documents/infra/docker/docker-hub/</link>
      <pubDate>Sun, 31 May 2020 01:59:00 +0900</pubDate>
      
      <guid>https://yeh35.github.io/blog.github.io/documents/infra/docker/docker-hub/</guid>
      <description>들어가기 이번에는 Docker Hub에 대해서 알아볼 것이다. Docker Image를 만들었다면 이 이미지를 배포 혹은 공유할 수 있는 방법이다.
Docker Hub Github와 같은 Docker Hub라는 사이트가 있다. Github와 다른 것은 Private Repository를 하나밖에 못사용 한다는 것?
(불만이 있다면 Registry Server를 직접 구축해도 된다)
사이트에서 회원가입을 하고 Console에서 docker login이라고 입력하면 Docker Hub에 로그인 할 수 있다.
Image Tag 구성 도커 이미지 이름은 다음과 같은 형태로 구성된다. [Registry URL]/[사용자 ID]/[이미지명]:[tag]
 Registry URL 기본 URL은 docker.</description>
    </item>
    
    <item>
      <title>AWS API 서버 띄우기 까지 - 2</title>
      <link>https://yeh35.github.io/blog.github.io/documents/infra/aws/aws-study-start-2/</link>
      <pubDate>Sun, 31 May 2020 01:00:00 +0900</pubDate>
      
      <guid>https://yeh35.github.io/blog.github.io/documents/infra/aws/aws-study-start-2/</guid>
      <description>해당 글은 의식의 흐름대로 작성 이 되어있다.
AWS 사이트에 가입을 굳이 설명할 필요는 없으므로 생략!
도메인 구입! Route53에서 도메인까지 구입할 수 있다.
누가 sangoh.com을 쓰고 있기에.. sangoh.net으로 하기로 했다.
이제 도메인을 삿으니 기다리면 된다.. (카드에 돈있는지 확인 필수)
echo 서버 만들기 도메인 승인 떨어질때 까지 할일이 없으니 echo 서버를 만들자! Spring Boot로 만들고 다음과 같은 코드를 추가하였다.
@RestControllerpublic class Controller {@GetMapping(&amp;quot;/echo/{text}&amp;quot;)@ResponseBodypublic String echo(@PathVariable(&amp;quot;text&amp;quot;) String text) {return text;}}이제 echo 서버를 도커 이미지로 꿉기!</description>
    </item>
    
    <item>
      <title>AWS API 서버 띄우기 까지 - 1</title>
      <link>https://yeh35.github.io/blog.github.io/documents/infra/aws/aws-study-start-1/</link>
      <pubDate>Sat, 30 May 2020 01:00:00 +0900</pubDate>
      
      <guid>https://yeh35.github.io/blog.github.io/documents/infra/aws/aws-study-start-1/</guid>
      <description>해당 글은 의식의 흐름대로 작성 이 되어있다.
시작은&amp;hellip; 친구에게 AWS를 물어보니 숙제로 답이 왔다&amp;hellip;
숙제 시작..
일단 저게 다 뭐야.. Amazon Route 53 클라우드 Domain Name System (DNS) 웹 서비스라고 하네요
DNS서버가 Domain을 IP 주소로 변경해주는 것은 알고 있는데&amp;hellip;
그럼 DNS 서버는 어떻게 작동하지&amp;hellip;? 모든 단말(PC)은 DNS 서버의 IP 주소가 설정되어 있다. (되어있어야 한다)
Window 같은 경우 콘솔에 ipconfig /all 명령을 입력하면 다음과 같이 DNS 서버를 알 수 있다.
...DNS 서버.</description>
    </item>
    
    <item>
      <title>Docker 컨테이너, Image, Dockerfile</title>
      <link>https://yeh35.github.io/blog.github.io/documents/infra/docker/docker-container-image-dockerfile/</link>
      <pubDate>Thu, 28 May 2020 23:00:46 +0900</pubDate>
      
      <guid>https://yeh35.github.io/blog.github.io/documents/infra/docker/docker-container-image-dockerfile/</guid>
      <description>들어가기 Docker 컨테이너 뭐고 Docker Image의 생성 Dockerfile은 어떻게 실행되는지 정리하려고 한다.
Application 환경세팅 문제 우리가 만드는 Application은 실행되는 환경에 따라 OS와 동적 Library에 의존성을 가진다.
즉, Application이 실행되기 위해서는 OS, 동적 Library라는 실행환경이 필요하다.
여기서 문제는 하나의 시스템위에 여러개의 Application을 실행하려고 할때이다.
각 Application이 동일한 라이브러리 버전과 동일한 OS가 필요하다면 상관이 없겠지만
그렇지 않는다고 하면 세팅 지옥의 문이 열린다. (혹시 하나의 Application만 실행하면 되지 라고 생각했다면 간단한 블로그를 띄우려고 해도 WebServer, DB, WebApplication이라는 3개나 필요하다)</description>
    </item>
    
    <item>
      <title>김정호 3시간만에 끝내는 영문법 총정리</title>
      <link>https://yeh35.github.io/blog.github.io/documents/english/%EA%B9%80%EC%A0%95%ED%98%B8-3%EC%8B%9C%EA%B0%84%EB%A7%8C%EC%97%90-%EB%81%9D%EB%82%B4%EB%8A%94-%EC%98%81%EB%AC%B8%EB%B2%95-%EC%B4%9D%EC%A0%95%EB%A6%AC/</link>
      <pubDate>Mon, 25 May 2020 12:19:01 +0900</pubDate>
      
      <guid>https://yeh35.github.io/blog.github.io/documents/english/%EA%B9%80%EC%A0%95%ED%98%B8-3%EC%8B%9C%EA%B0%84%EB%A7%8C%EC%97%90-%EB%81%9D%EB%82%B4%EB%8A%94-%EC%98%81%EB%AC%B8%EB%B2%95-%EC%B4%9D%EC%A0%95%EB%A6%AC/</guid>
      <description>8품사 글을 구성하는 구속품 8가지
  명사
사람, 사물, 개념, 행동 등의 이름
tommy: car, water, peace, answer, shower
  대명사 명사를 대신 받아주는 것
  인칭 대명사: 유일하게 격 의 구분이 있다. (목적어, 소유격 등등 나눠진다)   지시 대명사: (~한 것), 지시해주는 말 This, That, these, those, such
  부정 대명사: 정해져 있지 않은 것을 지시 all, some, any, none, each, another, other(s), one(s), much, little, few</description>
    </item>
    
    <item>
      <title>Docker 기본 명령어 정리</title>
      <link>https://yeh35.github.io/blog.github.io/documents/infra/docker/docker-command/</link>
      <pubDate>Sun, 24 May 2020 11:52:46 +0900</pubDate>
      
      <guid>https://yeh35.github.io/blog.github.io/documents/infra/docker/docker-command/</guid>
      <description>들어가기 Docker 명령어를 자꾸 까먹어서 정리하는 차원에 글을 작성한다.
Dokcer가 처음이신 분들은 subicura님의 도커 안내서 를 추천드리고 싶다. (사실 이 글도 subicura님의 도커 안내서를 요약한 것일 뿐이다.)
도커 버전확인 docker version명령어를 입력하면 Client와 Server 정보 두개가 보인다.
Docker는 하나의 실행 파일이지만 Client와 Server 역할을 각각 할 수 있다
커맨드를 입력하면 Client가 Server로 전송하고 결과를 받아 출력해준다.
도커의 실행 docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]옵션[OPTIONS]  -d : detached mode 흔히 말하는 백그라운드 모드 -p : 호스트와 컨테이너의 포트를 연결 (포워딩) -v : 호스트와 컨테이너의 디렉토리를 연결 (마운트) -e : 컨테이너 내에서 사용할 환경변수 설정 –name : 컨테이너 이름 설정 –rm : 프로세스 종료시 컨테이너 자동 제거 -it : -i와 -t를 동시에 사용한 것으로 터미널 입력을 위한 옵션 –link : 컨테이너 연결 [컨테이너명:별칭]  컨테이너 목록 확인 docker ps [OPTIONS]기본은 실행중인 컨테이너 목록만 보여줌</description>
    </item>
    
    <item>
      <title>초보자를 위한 Gradle 안내서 4편: 각자의 프로젝트로</title>
      <link>https://yeh35.github.io/blog.github.io/documents/infra/gradle/gradle-start4/</link>
      <pubDate>Sat, 23 May 2020 22:40:00 +0900</pubDate>
      
      <guid>https://yeh35.github.io/blog.github.io/documents/infra/gradle/gradle-start4/</guid>
      <description>커리큘럼  Build툴?, Gradle은 무엇인가? Gradle 아키텍쳐 Task 각자의 프로젝트로  이어서.. 여기까지 읽으셨다면 정말 고생하셨습니다.
이제 거의 마지막을 달리고 있습니다.
Gradle의 철학 과 Task의 작동방식 을 설명하였다.
물론 아직 Gradle을 완벽하게 다루기에는 제 설명이 분명 부족한 내용들이 존재한다. 하지만 제 판단에는 앞의 내용을들 완전히 숙지하셨다면 각 Plugin 혹은 Gradle이 출력해주는 로그가 어떤 의미인지 찾아볼 능력 이 생겼을 것이라고 생각한다
이제 각자의 프로젝트에 가서 사용하는 Plugin이 어떻게 작동 하는지
build.gradle의 내용을 보며 공부하시면 된다.</description>
    </item>
    
    <item>
      <title>초보자를 위한 Gradle 안내서 3편: Task</title>
      <link>https://yeh35.github.io/blog.github.io/documents/infra/gradle/gradle-start3/</link>
      <pubDate>Sat, 23 May 2020 12:40:00 +0900</pubDate>
      
      <guid>https://yeh35.github.io/blog.github.io/documents/infra/gradle/gradle-start3/</guid>
      <description>커리큘럼  Build툴?, Gradle은 무엇인가? Gradle 아키텍쳐 Task 각자의 프로젝트로  이어서.. 전편에서 gradle의 아키텍쳐와 철학 그리고 Lifecycle(생명주기) 에 대해서 다뤘다.
이번 편에서는 Task에 대해서 자세하게 다뤄보려고 한다.
Task? 앞에서 task는 Gradle의 실행단위라고 하였는데 실행단위를 어떤 작업을 하는 약속된 하나의 객체라고 생각하면 된다.
Gradle의 초기화 &amp;gt; 구성 &amp;gt; 실행 3단계에서 실행 단계에서 실질적으로 우리가 원하는 기능을 하는 것은 task다. (사실 모든건 task를 실행하기 위한 준비일 뿐이였다..)
처음에 Console에서 gradle init 명령을 통해 프로젝트를 생성 했었을 것이다.</description>
    </item>
    
    <item>
      <title>초보자를 위한 Gradle 안내서 2편: Gradle 아키텍쳐</title>
      <link>https://yeh35.github.io/blog.github.io/documents/infra/gradle/gradle-start2/</link>
      <pubDate>Fri, 22 May 2020 12:40:00 +0900</pubDate>
      
      <guid>https://yeh35.github.io/blog.github.io/documents/infra/gradle/gradle-start2/</guid>
      <description>커리큘럼  Build툴?, Gradle은 무엇인가? Gradle 아키텍쳐 Task 각자의 프로젝트로  이어서.. 전편에서는 Build라는게 무엇을 뜻하고 Gradle 설치랑 Gradle wrapper, Gradle의 파일들의 의미에 대해서 봤었다.
(까먹었다면 돌아가세욧!)
이번에는 Gradle의 철학과 아키텍쳐에 대한 내용이다. 겁먹지마요 어렵지 않아요&amp;hellip;
Groovy.. 앞으로 내용 중간중간에 스크립트가 나올 것인데 Groovy 문법에 모르신다면 여기를 눌러서 문법을 한번 읽어보시는 것을 추천드리고 싶다.
Gradle 아키텍쳐 구조 Gradle은 core(본체)와 Plugin으로 나눠져 있다. 갑자기 Plugin? 이라고 생각이 들 수 있지만 사실 Gradle은 빌드툴임에도 빌드 기능은 Core가 아닌 Plugin으로 구현되어 있다</description>
    </item>
    
    <item>
      <title>초보자를 위한 Gradle 안내서 1편: Build툴?, Gradle은 무엇인가?</title>
      <link>https://yeh35.github.io/blog.github.io/documents/infra/gradle/gradle-start1/</link>
      <pubDate>Thu, 21 May 2020 20:40:00 +0900</pubDate>
      
      <guid>https://yeh35.github.io/blog.github.io/documents/infra/gradle/gradle-start1/</guid>
      <description>들어가면서 이 글은 그레이들을 처음 접하는 사람보다 Android studio 혹은 그외에서 사용은 하는데 뭐지 알아서 되네 정도로 쓰시는 분들을 타겟으로 작성하였다. (제가 그랬거든요 ㅎㅎ)
gradle의 마법같은 작동을 공식문서와 gradle의 파일들을 열어보면서 해체 할 것이다.
커리큘럼  Build툴?, Gradle은 무엇인가? Gradle 아키텍쳐 Task 각자의 프로젝트로  빌드툴이란 위키에서는 빌드를 다음과 같이 정의하고 있다. 소프트웨어 빌드는 소스 코드 파일을 컴퓨터나 휴대폰에서 실행할 수 있는 독립(standalone) 소프트웨어 가공물로 변환하는 과정을 말하거나 그에 대한 결과물을 일컫는다.</description>
    </item>
    
    <item>
      <title>Groovy 문법</title>
      <link>https://yeh35.github.io/blog.github.io/documents/infra/gradle/groovy-grammar/</link>
      <pubDate>Mon, 18 May 2020 20:40:15 +0900</pubDate>
      
      <guid>https://yeh35.github.io/blog.github.io/documents/infra/gradle/groovy-grammar/</guid>
      <description>Groovy 문법 Gradle을 편하게 사용하기 위해서는 Groovy문법이 필요하다. 물론 요즘은 Kotlin으로 작성할 수 있다고는 하지만 아직 많은 예제소스들이 Groovy로 되어있어서 완전히 모를 수는 없다. Groovy에 대해 깊게 보는 것이 아닌 Gradle을 사용하면서 이정도는 알자라는 느낌으로 Groovy 공식 문서를 정리하였다. 솔직히 한번쭉 읽고 넘어가자 (필요할때 찾아쓰는걸로..)
Semicolons Groovy에서는 세미콜론이 있어도 없어도 된다.
println &#39;Hello World&#39;;println &#39;Hello World&#39;Parentheses 괄호 역시 필수가 아니다.
println (&#39;Hello World&#39;)println &#39;Hello World&#39;def KeyWord def 키워드를 사용하면 함수도 변수도 타입을 명시적으로 지정하지 않아도 된다.</description>
    </item>
    
    <item>
      <title>Spring Boot를 이용한 Slack Webhooks 사용하기</title>
      <link>https://yeh35.github.io/blog.github.io/documents/spring/spring-slack-webhooks/</link>
      <pubDate>Sat, 16 May 2020 23:27:20 +0900</pubDate>
      
      <guid>https://yeh35.github.io/blog.github.io/documents/spring/spring-slack-webhooks/</guid>
      <description>Slack README에 예제 소스와 사용법은 아래 Github에 적어놓았다.
GitHub https://github.com/Yeh35/spring-boot-webhook-example</description>
    </item>
    
    <item>
      <title>What is REST API(그런 REST API로 괜찮은가)</title>
      <link>https://yeh35.github.io/blog.github.io/documents/web/what_is_rest_api/</link>
      <pubDate>Sun, 10 May 2020 15:45:22 +0900</pubDate>
      
      <guid>https://yeh35.github.io/blog.github.io/documents/web/what_is_rest_api/</guid>
      <description>이응준님의 &amp;ldquo;그런 REST API로 괜찮은가&amp;rdquo; 발표를 보고 정리한 내용이다.
REST API란?  REpresentational State Transfer REST 아키텍처를 따르는 API 인터넷 상의 시스템 간의 상호 운용성(interoperabiliy)을 제공하는 방법중 하나 시스템 제각각의 독립적인 진화를 보장하기 위한 방법  REST 아키택처 스타일란?  client-server stateless cache uniform interface layered system code-on-demand (optional)  (아키택처 스타일이란 제약조건의 집합) 나머지는 잘 지켜지지만 uniform interface는 쉽게 지켜지지 않는다..
Uniform Interface의 제약 조건  Identification or resource : 리소스가 URL로 식별되면 된다.</description>
    </item>
    
    <item>
      <title>다이나믹 프록시</title>
      <link>https://yeh35.github.io/blog.github.io/documents/java/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9_%ED%94%84%EB%A1%9D%EC%8B%9C/</link>
      <pubDate>Sun, 10 May 2020 12:40:07 +0900</pubDate>
      
      <guid>https://yeh35.github.io/blog.github.io/documents/java/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9_%ED%94%84%EB%A1%9D%EC%8B%9C/</guid>
      <description>사전 지식  java Class loading (실행과정) java 리플렉션  프록시 패턴  프록시와 리얼 서브젝트가 같은 인터페이스를 상속받고 클라이언트는 인터페이스를 프록시 타입으로 선언해서 사용한다. 프록시에서는 앞뒤로 부가 가능을 추가하고 리얼 서브젝트를 호출 한다.   결과적으로 리얼 서브젝트는 제공하는 핵심기능을 유지하며 코드 변경 없이 부가적인 기능(트렌젝션, 접근 제어, 로깅)을 제공할 수 있다.  다이나믹 프록시  테스트 코드 실행을 위해서 junit4를 사용할 것이다.    프록시 패턴 인터페이스가 필요하듯 인터페이스를 추가한다</description>
    </item>
    
    <item>
      <title>문장 성분과 문장 형식</title>
      <link>https://yeh35.github.io/blog.github.io/documents/english/%EB%AC%B8%EC%9E%A5-%EC%84%B1%EB%B6%84%EA%B3%BC-%EB%AC%B8%EC%9E%A5-%ED%98%95%EC%8B%9D/</link>
      <pubDate>Sun, 10 May 2020 12:19:01 +0900</pubDate>
      
      <guid>https://yeh35.github.io/blog.github.io/documents/english/%EB%AC%B8%EC%9E%A5-%EC%84%B1%EB%B6%84%EA%B3%BC-%EB%AC%B8%EC%9E%A5-%ED%98%95%EC%8B%9D/</guid>
      <description>문장성분 주어(S) (~은, 는, 이, 가) 동사(V) 목적어(O) (~을[를], 에게) 보어(C)  주어의 의미나 상태를 보충 설명, 두개로 나뉜다. 주격 보어 (주격을 수식) 목적격 보어 (목적어를 수식)  수식어(M)  부사, 전명구는 무줘건 수식어!!
물론 형용사도 수식어가 될 수 있다.  보어(C),수석어(M)을 구분  수식어와 주격보어의 구별: 주어와의 관련성  He remained here all night: &amp;lsquo;here&#39;은 부사고 부사는 무줘건 수식어 He remained poor all his life: &amp;lsquo;poor&#39;은 주어의 상태를 나타내는 주격 보어   수식어와 목적격보어의 구별: 목적어와의 관련성  I found the thick book easily : &amp;lsquo;easily&#39;는 목적어가 아닌 동사를 꾸며줌으로 수식어 I found the thick book easy to read : &amp;lsquo;easy to reads&#39;는 목적어를 꾸며줌으로 목적격보어    구와 절  구: 두 개 이상의 단어가 모여서 하나의 품사(하나의 뜻이 되는) 역할을 하는 것  의문사 + to부정사구는 &amp;ldquo;~해야할지&amp;rdquo;, &amp;ldquo;~할지&amp;quot;로 해석된다.</description>
    </item>
    
    <item>
      <title>꽃미남 교수님께 배우는 C언어(pocu Comp2200) 후기</title>
      <link>https://yeh35.github.io/blog.github.io/documents/pocu/comp2200/</link>
      <pubDate>Thu, 23 Apr 2020 21:22:02 +0900</pubDate>
      
      <guid>https://yeh35.github.io/blog.github.io/documents/pocu/comp2200/</guid>
      <description>comp2200?? 꽃미남(?) 포프님께 C언어를 배우는 과목이다.
과목이라고 표현한 것은 Comp2200을 듣기 위하서는 선수 과목들을 배우고 들어야 하기 때문이다.
(선수과목이 필수는 아니지만 풀코스를 수강한 학생으로써 선수과목은 사실상 필수라고 말하고 싶다.)
 꽃미남 사진의 출처 Pocu Academy COMP2200  C언어의 핵심 핵심은 아래 3가지라고 생각한다.
 포인터 메모리 관리 (할당/해제) 직관성  재직 중인 회사에서 주로 Java를 사용하기에 Java와 C언어를 간단하게 비교하면서 핵심들이 다른 언어에 어떤 식으로 녹아났고 그 가치에 대해서 보려고 한다.</description>
    </item>
    
    <item>
      <title>스프링 부트와 AWS로 혼자 구현하는 웹 서비스</title>
      <link>https://yeh35.github.io/blog.github.io/documents/spring/jojoldu-spring-boot-alone-building-book/</link>
      <pubDate>Tue, 21 Apr 2020 06:00:00 +0900</pubDate>
      
      <guid>https://yeh35.github.io/blog.github.io/documents/spring/jojoldu-spring-boot-alone-building-book/</guid>
      <description>Beginning 회사에서 Spring + Tomcat로 구축된 WAS에 신규 도메인을 추가할 일이 생겼다.
Java를 사용할 줄 알았기에 쉽게 할 줄 알았지만.. 현실은 코드 복붙을 하고 있는 나를 발견했다&amp;hellip; Spring에 대해서 공부를 해야겠다고 검색을 해보니 디자인부터 이쁜(?) 책이 있어서 사게 되었다.
 summary 책 제목처럼 서비스를 구현부터 서비스를 운영하는 과정을 간략하게 체험해 볼 수 있었다.
하지만 Intellij, Spring, Gradle을 잘 모른다면 삽질을 많이 해야한다.
이동욱작가님의 Github를 보고 환경 구축을 철저하게 하자.
 https://github.</description>
    </item>
    
    <item>
      <title>Hugo Blog 구축기</title>
      <link>https://yeh35.github.io/blog.github.io/documents/hugo/hugo-blog-builder/</link>
      <pubDate>Wed, 11 Mar 2020 20:36:25 +0900</pubDate>
      
      <guid>https://yeh35.github.io/blog.github.io/documents/hugo/hugo-blog-builder/</guid>
      <description>기술 블로그를 시작한 이유 멋진 기술 블로그들을 가보면 다들 글을 왜이렇게 잘 쓰는지&amp;hellip;
뭔가 멋있기도 하고 내가 뒤쳐저 있는 것 같기도 하고&amp;hellip;
그냥 그런 블로그를 가지고 싶었고 시작했다.
Hugo를 선택한 이유 처음에는 Tstory에 한 두개 정도 글을 썻다.
매우 편한 환경이였고 글을 맛갈나게 쓰는 것만 신경쓰면 되는 환경이였다.
하지만 한편에 아쉬움이 계속 남았다.
그래도 뭔가 더 이쁜 나만의 블로그를 가지고 싶다는 욕구가 해결되지 않았다.
친구랑 빵맥(빵에 맥주)을 하던 중 &amp;ldquo;깃 블로그 해봐&amp;quot;라는 말에 다음날 부랴부랴 찾게 되었다.</description>
    </item>
    
  </channel>
</rss>